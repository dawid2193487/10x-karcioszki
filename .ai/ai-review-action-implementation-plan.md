# API Endpoint Implementation Plan: Log AI Review Action

## 1. Endpoint Overview

This endpoint logs user actions during the review of AI-generated flashcards. When a user reviews flashcards generated by AI, they can accept them as-is, edit them before saving, or reject them entirely. This endpoint captures these decisions for analytics and quality improvement purposes.

**Business Context:**
- Tracks user engagement with AI-generated content
- Provides data for calculating AI acceptance rates
- Helps improve AI flashcard generation quality through user feedback
- Links accepted/edited flashcards to their AI generation source

## 2. Request Details

### HTTP Method & URL
- **Method:** `POST`
- **Path:** `/api/ai/review-actions`
- **File Location:** `src/pages/api/ai/review-actions.ts`

### Authentication
- **Required:** Yes
- **Type:** Supabase session-based authentication
- **Implementation:** Access `context.locals.supabase` for authenticated client

### Request Headers
```
Content-Type: application/json
```

### Request Body Structure
```typescript
LogAiReviewActionCommand {
  generation_log_id: string;      // UUID, required
  flashcard_id: string | null;    // UUID, optional (null for rejected)
  action_type: AiReviewActionType; // 'accepted' | 'edited' | 'rejected', required
  original_front: string;          // 1-1000 chars, required
  original_back: string;           // 1-1000 chars, required
  edited_front?: string;           // 1-1000 chars, required if action_type='edited'
  edited_back?: string;            // 1-1000 chars, required if action_type='edited'
}
```

### Parameters

**Required:**
- `generation_log_id` - UUID of the AI generation log entry
- `action_type` - Type of action: 'accepted', 'edited', 'rejected'
- `original_front` - Original AI-generated front side text
- `original_back` - Original AI-generated back side text

**Optional:**
- `flashcard_id` - UUID of created flashcard (null for rejected cards)

**Conditionally Required:**
- `edited_front` - Required when `action_type='edited'`, must be null otherwise
- `edited_back` - Required when `action_type='edited'`, must be null otherwise

## 3. Utilized Types

### Command Model (Request)
```typescript
// From src/types.ts
LogAiReviewActionCommand {
  generation_log_id: string;
  flashcard_id: string | null;
  action_type: AiReviewActionType;
  original_front: string;
  original_back: string;
  edited_front?: string;
  edited_back?: string;
}
```

### Response DTO
```typescript
// From src/types.ts
AiReviewActionDTO {
  id: string;
  generation_log_id: string;
  flashcard_id: string | null;
  action_type: AiReviewActionType;
  created_at: string;
}
```

### Supporting Types
```typescript
// From src/types.ts
type AiReviewActionType = 'accepted' | 'edited' | 'rejected';

// Database types
AiReviewActionInsert // From TablesInsert<'ai_review_actions'>
```

### Error Types
```typescript
// From src/types.ts
ErrorResponseDTO {
  error: {
    code: ErrorCode;
    message: string;
    details?: ErrorDetail[];
  }
}
```

## 4. Response Details

### Success Response (201 Created)
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "generation_log_id": "123e4567-e89b-12d3-a456-426614174000",
  "flashcard_id": "789e0123-e45b-67c8-d901-234567890abc",
  "action_type": "edited",
  "created_at": "2026-02-01T12:00:00Z"
}
```

### Error Responses

#### 400 Bad Request - Validation Failed
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [
      {
        "field": "edited_front",
        "message": "edited_front is required when action_type is 'edited'"
      }
    ]
  }
}
```

#### 401 Unauthorized - Missing/Invalid Token
```json
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Authentication required. Please log in."
  }
}
```

#### 404 Not Found - Generation Log Not Found
```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "AI generation log not found or does not belong to user"
  }
}
```

#### 500 Internal Server Error
```json
{
  "error": {
    "code": "INTERNAL_ERROR",
    "message": "An unexpected error occurred"
  }
}
```

## 5. Data Flow

### 1. Request Processing
```
Client Request
    ↓
Middleware (authentication check)
    ↓
API Endpoint Handler (POST function)
    ↓
Input Validation (Zod schema)
    ↓
Service Layer
```

### 2. Service Layer Operations
```
AiReviewActionService.create()
    ↓
1. Verify generation_log_id exists and belongs to user
    ↓
2. Insert review action record into ai_review_actions table
    ↓
3. Return created record
```

### 3. Database Interaction
```sql
-- Verify ownership
SELECT id, user_id 
FROM ai_generation_logs 
WHERE id = $1 AND user_id = $2;

-- Insert review action
INSERT INTO ai_review_actions (
  user_id,
  generation_log_id,
  flashcard_id,
  action_type,
  original_front,
  original_back,
  edited_front,
  edited_back
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING *;
```

### 4. Response Transformation
```
Database Record (AiReviewAction entity)
    ↓
Transform to AiReviewActionDTO
    ↓
Return JSON Response (201 Created)
```

## 6. Security Considerations

### Authentication
- **Requirement:** User must be authenticated via Supabase session
- **Implementation:** 
  - Use `context.locals.supabase` from middleware
  - Call `supabase.auth.getUser()` to verify session
  - Return 401 if no valid session exists

### Authorization
- **Generation Log Ownership:**
  - Verify `generation_log_id` belongs to authenticated user
  - Query: `SELECT id FROM ai_generation_logs WHERE id = $1 AND user_id = $2`
  - Return 404 if not found or doesn't belong to user

### Data Validation
- **Input Sanitization:**
  - Use Zod for type-safe validation
  - Enforce string length limits (1-1000 chars)
  - Validate UUID formats
  - Validate enum values for action_type

### Row-Level Security (RLS)
- **Supabase RLS Policies:**
  - Users can only insert their own review actions
  - Policy: `user_id = auth.uid()`
  - Prevents unauthorized data manipulation

### Potential Security Threats
1. **SQL Injection:** Mitigated by Supabase parameterized queries
2. **XSS:** Client-side concern, but limit string lengths
3. **CSRF:** Mitigated by session-based auth
4. **Data Leakage:** Ensure generation_log ownership check
5. **Mass Assignment:** Use explicit field mapping, not spreading entire request body

## 7. Error Handling

### Validation Errors (400)

| Scenario | Field | Message | Details |
|----------|-------|---------|---------|
| Invalid UUID | `generation_log_id` | Invalid UUID format | Field-specific error |
| Missing field | `action_type` | Required field | Field-specific error |
| String too long | `original_front` | Must be between 1 and 1000 characters | Field-specific error |
| Invalid enum | `action_type` | Must be one of: accepted, edited, rejected | Field-specific error |
| Conditional missing | `edited_front` | Required when action_type is 'edited' | Field-specific error |
| Conditional present | `edited_front` | Must be null when action_type is not 'edited' | Field-specific error |

### Authentication Errors (401)

| Scenario | Message |
|----------|---------|
| No session | Authentication required. Please log in. |
| Invalid token | Invalid authentication token |
| Expired session | Session expired. Please log in again. |

### Not Found Errors (404)

| Scenario | Message |
|----------|---------|
| Generation log not found | AI generation log not found or does not belong to user |
| Invalid generation_log_id | AI generation log not found |

### Server Errors (500)

| Scenario | Message | Logging |
|----------|---------|---------|
| Database error | An unexpected error occurred | Log full error with stack trace |
| Supabase connection error | Database connection failed | Log error details |
| Unexpected exception | An unexpected error occurred | Log full error context |

### Error Handling Implementation Strategy

1. **Early Returns:** Handle errors at the beginning of functions
2. **Guard Clauses:** Validate preconditions before processing
3. **Try-Catch:** Wrap service calls in try-catch blocks
4. **Error Transformation:** Convert service errors to API error responses
5. **Logging:** Use `error-handler.ts` utility for consistent error logging
6. **User-Friendly Messages:** Return helpful messages without exposing internals

## 8. Performance Considerations

### Database Optimization
- **Indexes Required:**
  - `ai_review_actions(generation_log_id)` - for querying by generation
  - `ai_review_actions(user_id)` - for user-specific queries
  - `ai_review_actions(flashcard_id)` - for flashcard tracking
  - `ai_generation_logs(id, user_id)` - composite for ownership check

### Query Performance
- **Ownership Verification:**
  - Single query: `SELECT id FROM ai_generation_logs WHERE id = $1 AND user_id = $2`
  - Expected latency: < 10ms with proper indexing
  
- **Insert Operation:**
  - Single insert with RETURNING clause
  - Expected latency: < 20ms

### Potential Bottlenecks
1. **Database Connection Pool:** Ensure Supabase connection pooling is configured
2. **Validation Overhead:** Zod validation is fast, minimal impact
3. **Network Latency:** Between Astro server and Supabase

### Optimization Strategies
1. **Connection Reuse:** Use `context.locals.supabase` (shared connection)
2. **Minimal Data Transfer:** Return only necessary fields in DTO
3. **Avoid N+1 Queries:** Single ownership verification query
4. **Database Constraints:** Let database enforce constraints where possible

### Rate Limiting
- **Consideration:** Should review actions be rate-limited?
  - Legitimate use: User reviewing 10-20 AI-generated cards quickly
  - Potential abuse: Automated spam of review actions
  - **Recommendation:** Implement generous rate limit (e.g., 100 requests/minute per user)
  - **Implementation:** Use existing `rate-limiter.service.ts` if available

## 9. Implementation Steps

### Step 1: Create Validation Schema
**File:** `src/lib/schemas/ai-review-action.schema.ts`

```typescript
import { z } from 'zod';

export const logAiReviewActionSchema = z.object({
  generation_log_id: z.string().uuid('Invalid generation log ID'),
  flashcard_id: z.string().uuid('Invalid flashcard ID').nullable(),
  action_type: z.enum(['accepted', 'edited', 'rejected'], {
    errorMap: () => ({ message: 'Must be one of: accepted, edited, rejected' })
  }),
  original_front: z.string()
    .min(1, 'Original front must not be empty')
    .max(1000, 'Original front must not exceed 1000 characters'),
  original_back: z.string()
    .min(1, 'Original back must not be empty')
    .max(1000, 'Original back must not exceed 1000 characters'),
  edited_front: z.string()
    .min(1, 'Edited front must not be empty')
    .max(1000, 'Edited front must not exceed 1000 characters')
    .optional(),
  edited_back: z.string()
    .min(1, 'Edited back must not be empty')
    .max(1000, 'Edited back must not exceed 1000 characters')
    .optional(),
}).refine((data) => {
  // If action_type is 'edited', both edited fields must be present
  if (data.action_type === 'edited') {
    return data.edited_front !== undefined && data.edited_back !== undefined;
  }
  return true;
}, {
  message: 'edited_front and edited_back are required when action_type is "edited"',
  path: ['edited_front'],
}).refine((data) => {
  // If action_type is not 'edited', edited fields must be absent
  if (data.action_type !== 'edited') {
    return data.edited_front === undefined && data.edited_back === undefined;
  }
  return true;
}, {
  message: 'edited_front and edited_back must not be present when action_type is not "edited"',
  path: ['edited_front'],
});

export type LogAiReviewActionInput = z.infer<typeof logAiReviewActionSchema>;
```

### Step 2: Create Service Layer
**File:** `src/lib/services/ai-review-action.service.ts`

```typescript
import type { SupabaseClient } from '../db/supabase.client';
import type { AiReviewActionInsert, AiReviewAction } from '../types';
import { ApiError } from '../utils/error-handler';

export class AiReviewActionService {
  constructor(private supabase: SupabaseClient) {}

  /**
   * Verify that generation log exists and belongs to user
   */
  async verifyGenerationLogOwnership(
    generationLogId: string,
    userId: string
  ): Promise<void> {
    const { data, error } = await this.supabase
      .from('ai_generation_logs')
      .select('id')
      .eq('id', generationLogId)
      .eq('user_id', userId)
      .single();

    if (error || !data) {
      throw new ApiError(
        'AI generation log not found or does not belong to user',
        'NOT_FOUND',
        404
      );
    }
  }

  /**
   * Create a new AI review action record
   */
  async create(
    input: AiReviewActionInsert
  ): Promise<AiReviewAction> {
    const { data, error } = await this.supabase
      .from('ai_review_actions')
      .insert(input)
      .select()
      .single();

    if (error) {
      console.error('Error creating AI review action:', error);
      throw new ApiError(
        'Failed to create AI review action',
        'INTERNAL_ERROR',
        500
      );
    }

    return data;
  }
}
```

### Step 3: Create API Endpoint Handler
**File:** `src/pages/api/ai/review-actions.ts`

```typescript
import type { APIContext } from 'astro';
import { logAiReviewActionSchema } from '../../../lib/schemas/ai-review-action.schema';
import { AiReviewActionService } from '../../../lib/services/ai-review-action.service';
import { ApiError, handleApiError } from '../../../lib/utils/error-handler';
import type { 
  AiReviewActionDTO, 
  ErrorResponseDTO, 
  AiReviewActionInsert 
} from '../../../types';

export const prerender = false;

export async function POST(context: APIContext): Promise<Response> {
  try {
    // 1. Authentication check
    const supabase = context.locals.supabase;
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new ApiError(
        'Authentication required. Please log in.',
        'UNAUTHORIZED',
        401
      );
    }

    // 2. Parse and validate request body
    const body = await context.request.json();
    const validationResult = logAiReviewActionSchema.safeParse(body);

    if (!validationResult.success) {
      const details = validationResult.error.errors.map((err) => ({
        field: err.path.join('.'),
        message: err.message,
      }));

      const errorResponse: ErrorResponseDTO = {
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Validation failed',
          details,
        },
      };

      return new Response(JSON.stringify(errorResponse), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const validatedData = validationResult.data;

    // 3. Initialize service
    const reviewActionService = new AiReviewActionService(supabase);

    // 4. Verify generation log ownership
    await reviewActionService.verifyGenerationLogOwnership(
      validatedData.generation_log_id,
      user.id
    );

    // 5. Prepare insert data
    const insertData: AiReviewActionInsert = {
      user_id: user.id,
      generation_log_id: validatedData.generation_log_id,
      flashcard_id: validatedData.flashcard_id,
      action_type: validatedData.action_type,
      original_front: validatedData.original_front,
      original_back: validatedData.original_back,
      edited_front: validatedData.edited_front ?? null,
      edited_back: validatedData.edited_back ?? null,
    };

    // 6. Create review action
    const reviewAction = await reviewActionService.create(insertData);

    // 7. Transform to DTO
    const responseDto: AiReviewActionDTO = {
      id: reviewAction.id,
      generation_log_id: reviewAction.generation_log_id,
      flashcard_id: reviewAction.flashcard_id,
      action_type: reviewAction.action_type,
      created_at: reviewAction.created_at,
    };

    // 8. Return success response
    return new Response(JSON.stringify(responseDto), {
      status: 201,
      headers: { 'Content-Type': 'application/json' },
    });

  } catch (error) {
    return handleApiError(error);
  }
}
```

### Step 4: Update Error Handler (if needed)
**File:** `src/lib/utils/error-handler.ts`

Ensure `ApiError` class and `handleApiError` function exist and support the error codes used:
- VALIDATION_ERROR
- UNAUTHORIZED
- NOT_FOUND
- INTERNAL_ERROR

### Step 5: Add Unit Tests (Optional but Recommended)
**File:** `src/pages/api/ai/__tests__/review-actions.test.ts`

Test cases:
1. ✅ Successfully create review action for 'accepted'
2. ✅ Successfully create review action for 'edited' with edited fields
3. ✅ Successfully create review action for 'rejected' with null flashcard_id
4. ❌ Return 400 for missing required fields
5. ❌ Return 400 for invalid UUID format
6. ❌ Return 400 for string exceeding 1000 characters
7. ❌ Return 400 for 'edited' without edited_front/edited_back
8. ❌ Return 400 for 'accepted' with edited_front/edited_back present
9. ❌ Return 401 for unauthenticated request
10. ❌ Return 404 for non-existent generation_log_id
11. ❌ Return 404 for generation_log_id belonging to different user

### Step 6: Manual Testing Checklist

**Prerequisites:**
- ✅ Authenticated user session
- ✅ Valid generation_log_id in database belonging to test user
- ✅ Valid flashcard_id (for accepted/edited cases)

**Test Scenarios:**

1. **Accept Action:**
```bash
curl -X POST http://localhost:3000/api/ai/review-actions \
  -H "Content-Type: application/json" \
  -d '{
    "generation_log_id": "valid-uuid",
    "flashcard_id": "valid-uuid",
    "action_type": "accepted",
    "original_front": "Test front",
    "original_back": "Test back"
  }'
```
Expected: 201 Created

2. **Edit Action:**
```bash
curl -X POST http://localhost:3000/api/ai/review-actions \
  -H "Content-Type: application/json" \
  -d '{
    "generation_log_id": "valid-uuid",
    "flashcard_id": "valid-uuid",
    "action_type": "edited",
    "original_front": "Original front",
    "original_back": "Original back",
    "edited_front": "Edited front",
    "edited_back": "Edited back"
  }'
```
Expected: 201 Created

3. **Reject Action:**
```bash
curl -X POST http://localhost:3000/api/ai/review-actions \
  -H "Content-Type: application/json" \
  -d '{
    "generation_log_id": "valid-uuid",
    "flashcard_id": null,
    "action_type": "rejected",
    "original_front": "Test front",
    "original_back": "Test back"
  }'
```
Expected: 201 Created

4. **Validation Error - Missing edited fields:**
```bash
curl -X POST http://localhost:3000/api/ai/review-actions \
  -H "Content-Type: application/json" \
  -d '{
    "generation_log_id": "valid-uuid",
    "flashcard_id": "valid-uuid",
    "action_type": "edited",
    "original_front": "Test front",
    "original_back": "Test back"
  }'
```
Expected: 400 Bad Request

5. **Not Found - Invalid generation_log_id:**
```bash
curl -X POST http://localhost:3000/api/ai/review-actions \
  -H "Content-Type: application/json" \
  -d '{
    "generation_log_id": "00000000-0000-0000-0000-000000000000",
    "flashcard_id": null,
    "action_type": "rejected",
    "original_front": "Test front",
    "original_back": "Test back"
  }'
```
Expected: 404 Not Found

### Step 7: Documentation Updates

1. **Update API Documentation:**
   - Add endpoint to `docs/API.md`
   - Include request/response examples
   - Document error scenarios

2. **Update Implementation Guide:**
   - Add service usage examples to `docs/IMPLEMENTATION.md`
   - Document validation rules

3. **Update Testing Guide:**
   - Add test scenarios to `docs/TESTING.md`

### Step 8: Database Verification

1. **Verify RLS Policies:**
```sql
-- Check if RLS is enabled
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE tablename = 'ai_review_actions';

-- Check RLS policies
SELECT * FROM pg_policies 
WHERE tablename = 'ai_review_actions';
```

2. **Verify Indexes:**
```sql
-- Check existing indexes
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'ai_review_actions';
```

3. **Verify Constraints:**
```sql
-- Check constraints
SELECT conname, contype, pg_get_constraintdef(oid) 
FROM pg_constraint 
WHERE conrelid = 'ai_review_actions'::regclass;
```

### Step 9: Deployment Checklist

- [ ] Code review completed
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed
- [ ] Error handling verified
- [ ] Authentication/authorization verified
- [ ] Database migrations applied (if any)
- [ ] RLS policies verified
- [ ] API documentation updated
- [ ] Monitoring/logging configured
- [ ] Performance benchmarks met

## 10. Additional Considerations

### Analytics Integration
Consider future integration with analytics dashboard:
- Track acceptance rates by generation_log_id
- Monitor edit patterns to improve AI prompts
- Identify frequently rejected card patterns

### Future Enhancements
1. **Batch Review Actions:** Allow logging multiple review actions in single request
2. **Undo Capability:** Track action history for potential undo feature
3. **Feedback Comments:** Allow users to add optional feedback text
4. **Quality Scoring:** Track quality metrics for AI-generated cards
